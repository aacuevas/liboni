# oepcie Library Design Requirements and Constraints
__WARNING__ This is a work in progress and there are inconsistencies.

## High-level considerations
### License

[MIT](https://en.wikipedia.org/wiki/MIT_License)

### Purpose
Configure hardware and read stream data from a host applications.

### High-Level Requirements
- Low latency (sub millisecond)
- High bandwidth (> 1000 neural data channels)
- Support for different hardware components on a single PCIe bus
    - Generic configuration channels
    - Generic output channels
    - Generic data input stream
- Useable by different host applications
- Support multiple PCIe devices on one PC
- Cross platform

### Language
Implementation shall be in C to facilitate cross platform and cross-language
use.

### Size and External Dependencies
[Xillybus](http://xillybus.com/) will be used for PCIe communication.
Therefore, this library will serve a simple wrapper around this functionality
to open up the communication channels described in High Level Requirements,
above. For this reason, the library should be limited to one header and one
source exposing a set of functions that can be downloaded and dropped into an
project.

## Mid-level Considerations

#### Context
A context holds all required state information for a devices associated with
one PCIe bus in the following hierarchy:
    - Communication channel handles (struct)
        - Device map channel
        - Configuration channel
        - Data channel
    - Device map (array of structs)
        - Device object handles
            - Device specific configuraiton commands
            - Device data map
        - Device clock heirarchy index
    - Acquisition state (enum)
        - Undefine
        - Configuration
        - Running

State details should be hidden in implementation file (.c). Pointer to opaque
type is exposed publicly in header (.h)

```
// .h
typedef struct oe_ctx_impl *oe_ctx;
int oe_make_ctx(oe_ctx **ctx);

// .c
struct oe_ctx_impl {
    // state
}
```

#### Communication Channels
The library must supports communication over the following channels

1. Device ID channel (synchronous?)
    - Upon hardware startup, this channel is filled with a hardware ID map
      (enumeration <-> ID) for each device, including the host PCIe hardware (index 0).
    - Index: unique index to which each device is referred by the host firmware.
    - ID: device type identifier which can be used to access device
      capabily and command map information using the Command Map (e.g. 0x00 is
      host device, 0x01 is serdes headstage, etc)

2. Configuration channel (synchronous)
    - Supports reading a writing the following registers
        - Hardware enumeration (H) : hardware component
        - Address register (A) : specify enpoint on H
        - Payload register (P): specify configuration value to be written on write-trigger
        - Write Trigger: trigger P to be sent to A.
        - Read Trigger: trigger update of P with current value stored at A or NULL if not readable.

    - Address register values are provided in by a Register Map corresponding to each hardware ID available in (1).
    - Payload values are generated by Device instances

3. Data channel (asynchronous)
    - High-bandwidth forward communication channel from device to host.
    - FIFO is filled with untyped data once per master clock cycle
    - Packet size is determined by the attached device IDs and the device Data Map

#### Devices
Each device supported by this library shall define a struct with the following information.

1. Device ID
    - The type-specific device number
2. Command Map
    - Command addresses (e.g. that can be used to fill the A register above.
    - Command descriptions. Human readable descriptions of the purpose of each command address.
3. Data map
    - Byte-count list
    - Description:
4. Data size
    - Total bytes of each transmitted data packet from this device
5. Clock hierarchy index
    - Specifies precedence for master clock generation.


## API Spec

### Definitions and Relations

- TODO: Dependency/hierarchy graph

- context: opaque handle to a structure which contains hardware and device
  state information. There is generally one context per process using the
  library.
- device: one of potentially many peices of hardware within a context.
  Examples: headstage, digital IO board, analog IO board, etc.
- stream: a structure specifying parameters of a data stream.  A data stream is
  a "high bandwidth" connection between the host application and potentially
  many devices. The data associated with a particular device ends up as a set
  of bytes in a buffer that is sent to the device (output stream) or is
  acquired from the hardware (input stream). The location of these bytes within
  the stream is specified via the devices `data_map` and `data_size` members.
- configuration: A set of integers defining a configuration setting on a device.

### oe_create_ctx

Create a hardware context. A context is an opaque handle to a structure which
contains hardware and device state information, configuration capabilities, and
data format information. Initially, it is a blank slate. It is configured by
calls to `oe_set`.

``` {.c}
oe_ctx *oe_create_ctx();
```

#### Arguments

- `spec` [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
  context specification string
- `c` pointer to created context

#### Returns `int`

- An opaque handle to the newly created context if successful. Otherwise it
  shall return NULL and set errno to one of oe error values 

**Description**

During successful context creation the following actions take place

1.  Physical transport is defined (e.g. PCIe, socket, etc)
2.  The context state machine enters the INITIALIZED state

Tentatively, context specification is provided via URI string. This may
change.

### oe_destroy_ctx

Terminate a context and free bound resources.

``` {.c}
int oe_destroy_ctx(oe_ctx *c)
```

#### Arguments

-   `c` context

#### Returns `int`

-   Less than 0: `oe_error`

**Description**

Context termination is performed in the following steps:

1.  Any blocking operations will return immediately with error code
    TERMINATE
2.  Attached resources are released
3.  The context enters the UNINITIALIZED state

### oe_read_config

Read a configuration register from a device on a connected index.

``` {.c}
int oe_read_config(const oe_ctx c, int index, int key, int *value)
```

#### Arguments

-   `c` context
-   `index` physical index number
-   `key` key of register to read
-   `value` currently set register value

#### Returns `int`

-   Less than 0: `oe_error`

### oe_write_config

Set a configuration register on a device on a connected index

``` {.c}
int oe_write_config(const oe_ctx c, int index, int key, int value)
```

#### Arguments

-   `c` context
-   `index` physical index number
-   `key` key of register to write to
-   `value` value to write to register
-   `mask` bit mask applied to value before it is written

#### Returns `int`

-   Less than 0: `oe_error`

### oe_open_stream

Open a data stream on a connected index. The context is updated to include the
presence and direction specification of the stream.

``` {.c}
int oe_open_stream(oe_ctx c, int index, int stream=0)
```

#### Arguments

-   `c` context
-   `index` physical index number
-   `stream` stream number

#### Returns `int`

-   Less than 0: `oe_error`

### oe_close_stream

Close data stream on a connected index

``` {.c}
int oe_close_stream(oe_ctx c, int index)
```

#### Arguments

-   `c` context
-   `index` physical index number

#### Returns `int`

-   Less than 0: `oe_error`

### oe_get_stream_attr

Get stream input/output attributes.

``` {.c}
int oe_get_stream_attr(const oe_ctx c, int index, oe_stream_attr *a)
```

#### Arguments

-   `c` context
-   `index` physical index number
-   `stream` stream index on index
-   `a` stream attributes structure

#### Returns `int`

-   Less than 0: `oe_error`

### oe_set_stream_attr

Set stream input/output attributes

``` {.c}
int oe_set_stream_attr(oe_ctx c, int index, int stream, const oe_stream_attr *a)
```

#### Arguments

-   `c` context
-   `index` physical index number
-   `stream` stream index on index
-   `a` stream attributes structure

#### Returns `int`

-   Less than 0: `oe_error`

### oe_read_stream

Read data from an open stream

``` {.c}
int oe_read_stream(oe_ctx c, int index, int stream, int nbytes, void *data)
```

#### Arguments

-   `c` context
-   `index` physical index number
-   `stream` stream index on index
-   `data` buffer to read data into

#### Returns `int`

-   Greater than or equal to 0: number of bytes read
-   Less than 0: `oe_error`

### oe_write_stream

Write data to an open stream

``` {.c}
int oe_write_stream(oe_ctx c, int index, int stream, int nbytes, const void *data)
```

#### Arguments

-   `c` context
-   `index` physical index number
-   `stream` stream index on index
-   `data` buffer to write to stream

#### Returns `int`

-   Greater than or equal to 0: number of bytes written
-   Less than 0: `oe_error`

### oe_get_device_type

Query the device type (EEPROM specified) of breakout board attached to a
index.

``` {.c}
int oe_get_device_type(const oe_ctx c, int index)
```

#### Arguments

-   `c` context

#### Returns

-   0 if no device at index
-   Positive number indicating `oe_device_type`
-   Negative number indicating `oe_error`

Public Types
------------

### oe_ctx

``` {.c}
typedef void * oe_ctx
```

### oe_device_type

``` {.c}
typedef enum oe_device_t {
    OE_KC705,
    OE_SERDES_RAT_128,
    OE_SERDES_RAT_256,
    OE_SERDES_MOUSE_64,
    OE_SERDES_MOUSE_128,
} oe_device_type
```

### oe_stream_attr

``` {.c}
typedef struct {
    size_t buffer_size;
    int flags;
} oe_stream_attr
```

### oe_device

``` {.c}
typedef struct {
    oe_device_type dev;
    oe_stream_attr stream;
} oe_device
```

### oe_error

``` {.c}
typedef enum error {
    TERMINATE,
    ATTEMPT_WRITE_TO_INPUT_STREAM,
    ATTEMPT_READ_FROM_OUTPUT_STREAM,
    STREAM_DOES_NOT_EXIST,
    CONTEXT_DOES_NOT_EXIST,
} oe_error
```
Private Types
-------------

Two types are used to define an oe_ctx.

### oiContextImpl

``` {.c}
struct oiContextIml {
    //TODO: members
}
```

